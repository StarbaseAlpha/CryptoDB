"use strict";function CryptoDB(cryptic,datastore,memstore,secretKey,passwordKey){let SECRET=null,PASSWORD=null,RECOVERY=null;const files=datastore,index=memstore;let indexName=null,loading=!1,loaded=!1,saving=!1,unsaved=!1;const hashPath=async path=>{let exists=await index.get(path);return exists&&exists.value?exists.value:await cryptic.hmacSign(SECRET,path)},Load=async()=>{if(loaded)return!0;if(loading)return resume();SECRET=cryptic.decode(await cryptic.kdf(cryptic.fromText(secretKey),cryptic.fromText(passwordKey),cryptic.fromText("SECRET"),256)),PASSWORD=cryptic.decode(await cryptic.kdf(cryptic.fromText(passwordKey),cryptic.fromText(secretKey),cryptic.fromText("PASSWORD"),256)),RECOVERY=cryptic.decode(await cryptic.kdf(PASSWORD,SECRET,cryptic.fromText("RECOVERY"),256)),loading=!0,indexName=await cryptic.kdf(SECRET,PASSWORD,cryptic.fromText("INDEX"),256);let indexExists=(await files.get(indexName)).value;if(indexExists){let decrypted=await Decrypt(indexName,indexExists);await index.importDB(decrypted)}return loading=!1,loaded=!0},resume=()=>new Promise((resolve,reject)=>{setTimeout(()=>{resolve(Load())},100)}),save=async(force=!1)=>saving&&!force?(unsaved=!0,!0):(unsaved=!1,saving=!0,Encrypt(indexName,await index.exportDB()).then(encryptedFS=>{files.put(indexName,encryptedFS).then(async ok=>(saving=!1,!unsaved||save(!0)))})),Encrypt=async(path,data)=>{let random=cryptic.random(32),salt=cryptic.combine(random,cryptic.fromText(path)),bits=await cryptic.kdf(cryptic.combine(PASSWORD),salt,cryptic.fromText("ENCRYPT"),512),key=await cryptic.decode(bits).slice(0,32),ad=await cryptic.decode(bits).slice(32,64),encrypted=await cryptic.encrypt(JSON.stringify(data),key,ad),recovery=await cryptic.encrypt(path,RECOVERY);return cryptic.encode(random)+"."+encrypted+"."+recovery},Decrypt=async(path,payload)=>{let random=payload.split(".")[0],encrypted=payload.split(".").slice(1).join("."),salt=cryptic.combine(random,cryptic.fromText(path)),bits=await cryptic.kdf(cryptic.combine(PASSWORD),salt,cryptic.fromText("ENCRYPT"),512),key=await cryptic.decode(bits).slice(0,32),ad=await cryptic.decode(bits).slice(32,64),decrypted=await cryptic.decrypt(encrypted,key,ad);return JSON.parse(decrypted)},Put=async(path,data)=>{loaded||await Load();let hash=await hashPath(path),encrypted=await Encrypt(path,data);return await files.put(hash,encrypted),await index.put(path,hash),await save(),{event:"write",timestamp:Date.now(),key:path}},List=async(query={})=>{loaded||await Load();let body=Object.assign({},query);body.values=!0;let list=await index.list(body);if(query.values){let promises=[];for(let i=0;i<list.length;i++)promises.push(Get(list[i].key));return await Promise.all(promises)}return list.map(file=>file.key)},Get=async path=>{loaded||await Load();let hash=await hashPath(path),encrypted=(await files.get(hash)).value,decrypted=null;return encrypted&&(decrypted=await Decrypt(path,encrypted)),{key:path,value:decrypted}},importIndex=async indexData=>{loaded||await Load();let promises=[];for(let i=0;i<indexData.length;i++)promises.push(hashPath(indexData[i]).then(result=>({key:indexData[i],value:result})));let results=await Promise.all(promises);return await index.importDB(results),await save(),!0};return Load(),{put:Put,get:Get,del:async paths=>{loaded||await Load();let keyPaths=paths;"string"==typeof paths&&(keyPaths=[paths]);let promises=[];for(let i=0;i<keyPaths.length;i++)promises.push((async()=>{let hash=await hashPath(keyPaths[i]);await files.del(hash),await index.del(keyPaths[i])})());return await Promise.all(promises),await save(),{event:"delete",timestamp:Date.now(),keys:keyPaths}},list:List,importDB:async data=>{loaded||await Load();let paths=[];for(let i=0;i<data.length;i++)paths.push(data[i].key),await Put(data[i].key,data[i].value);return await save(),{event:"importDB",timestamp:Date.now(),keys:paths}},exportDB:async()=>(loaded||await Load(),List({values:!0})),deleteDB:async()=>{let deleted=await files.deleteDB();await index.deleteDB(),loaded=!1,indexName=null;Date.now();return deleted},onEvent:datastore.onEvent,exportIndex:async()=>(loaded||await Load(),index.list()),importIndex:importIndex,recoverIndex:async()=>{let items=await datastore.list({values:!0}),recovered=[];for(let i=0;i<items.length;i++)if(items[i].value&&"string"==typeof items[i].value&&5===items[i].value.split(".").length){let parts=items[i].value.split("."),path=await cryptic.decrypt(parts[3]+"."+parts[4],RECOVERY).catch(err=>null);path&&items[i].key!==path&&recovered.push(path)}return await importIndex(recovered)},deleteIndex:async()=>(await files.del(indexName),await index.deleteDB(),!0),hashPath:hashPath,raw:datastore}}"undefined"!=typeof module&&module&&module.exports&&(module.exports=CryptoDB);